# format string attack の tips
## stack 上のデータを leak
`printf` 関数を使って、 stack 上のデータを leak できる。 例えば、

- `printf("%lx")` は 2 番目の引数をアドレスだと解釈して、そのアドレスに格納されているデータを `long` もしくは `unsinged long` 型として 16 進数で出力する
- `printf("%5$lx")` は 6 番目の引数をアドレス...（同上）...
- `printf("%6$lx")` は 7 番目の引数をアドレス...（同上）...

アーキテクチャが x64 の場合、引数は以下のように register と stack に格納される。

|1番目|2番目|3番目|4番目|5番目|6番目|7番目以降|
|-|-|-|-|-|-|-|
|rdi|rsi|rdx|rcx|r8|r9|stack に順に push|

以下に、 `%n$lx` を使った場合の stack 上の位置とそれがどの引数に対応しているかの対応表を示す。

|stack 上の位置|引数|
|-|-|
|$rsp+0|7番目|
|$rsp+8|8番目|
|$rsp+16|9番目|
|$rsp+24|10番目|
|$rsp+32|11番目|

ここで、`$rsp+m` のデータを leak したい場合、`n` は以下のように計算すればいいことがわかる。

```
m = 6 + m / 8
```

## fsa で overwrite する際の `%c` 出力幅の決め方
fas で GOT overwrite などを行う際によく `%10c%9$hhn` のような format string を使う。これは以下のような意味がある。

- `%10c`: 対応する引数を 1 バイトの文字として考え、出力幅 10 文字で出力する （つまり、 10 バイト分の文字列が出力される）
- `%9$hnn`: 9 番目の引数をアドレスとして考え、それに対して今まで出力した文字列の長さの下位 1 バイトをそのアドレスに書き込む

この 2 つを組み合わせることで、任意の場所に対して、任意のバイトを書き込むことができる。
ここで、「**今まで出力した文字列の長さ**」をコントロールする方法(つまり、`%c` の出力幅の決め方)を以下にまとめる。

```
n: 現時点で出力した文字列の長さ
b: `%hhn` で書き込みたいバイト
m: 目的のバイトを書き込むための `%c` の出力幅

t = (b + (256 - n)) % 256
m = t    (if t >= 1)
  = 256  (otherwise)
```
